---
title: Preconditioning
---

\newcommand{\diag}{\operatorname{diag}}
\newcommand{\Diag}{\operatorname{Diag}}
\newcommand{\ip}[1]{\langle #1 \rangle}
****
Each iteration of the preconditioned Newton CG method approximately solves the trust-region subproblem
$$
\min_{s} \{\tfrac{1}{2} \ip{s, H_k s} + \ip{\nabla f_k,s } \mid \|s\|_M \leq \Delta\}
$$
where $\nabla f_k$ and $H_k$ are the current gradient and Hessian, and $M\approx H$ is a positive definite preconditioner. For the KL regularized LS problem,
$$
H_k = A S_k A^T + \lambda I, \quad S_k:= X_k - x_k x_k^T
$$
where $x_k$ is the current primal iterate and $X_k=\Diag(x_k)$.

We consider these preconditioners:

1. Diagonal, constant: $M = \Diag(AA^T) + \lambda I$
1. (not working) Diagonal, variable: $M = \Diag(AX_kA^T) + \lambda I$
1. (not yet implemented) Cholesky, constant: $M = AA^T + \lambda I$

The first two preconditioners have complexity $O(mn)$ to compute and $O(m)$ to apply. The third has cubic complexity, but that cost can be amortized over the Newton iterations.

```{julia}
#| code-fold: true
#| output: false 
using LinearAlgebra, NPZ, StatsPlots
using KLLS
import KLLS: KLLSModel, solve!
```
Load the synthetic UEG test problem:
```{julia}
data = try # needed because of vscode quirks while developing
    npzread("../data/synthetic-UEG_testproblem.npz")
catch
    npzread("./data/synthetic-UEG_testproblem.npz")
end
kldata = KLLSModel(data["A"], data["b_avg"])
```

Build the preconditioner object:
```{julia}
MAA = KLLS.DiagAAPreconditioner(kldata);
# MASA = KLLS.DiagASAPreconditioner(kldata) # NOT WORKING! ðŸ˜¢
# AA = KLLS.AAPreconditioner(kldata) # NOT ADVISED ðŸ˜± (at least for this problem)
```

Solve the problem with and without preconditioning:
```{julia}
#|output: false
kldata.Î»=1e-6
solve!(M) = solve!(kldata, M=M, trace=true)
statsI = solve!(I)
statsMAA = solve!(MAA)
# statsMASA = solve!(MASA)
# statsAA = solve!(AA)
```

Plot the dual objective value and cumulative CG iterations.
```{julia}
#|echo: false
label = hcat( 
    "no precon",
    "Diag(AA')"
    # "Diag(AGA')"
    )
pCG = plot([
    cumsum(statsI.tracer.cgits),
    cumsum(statsMAA.tracer.cgits),
    # cumsum(statsMASA.tracer.cgits),
    ],
    xlabel="Iteration", ylabel="cumulative CG Iterations", label=label, lw=2)
pObj = plot([
    statsI.tracer.dual_obj,
    statsMAA.tracer.dual_obj,
    # statsMASA.tracer.dual_obj,
    ],
    xlabel="Iteration",
    ylabel="dual objective",
    label=label, lw=2)
plot(pObj, pCG, layout=(1,2))
```
